name: CD

on:
  push:
    branches: [ "main" ]
  # üëâ Option (recommand√©e) pour n‚Äôex√©cuter CD **apr√®s CI r√©ussi** :
  # workflow_run:
  #   workflows: ["CI"]
  #   types: [ "completed" ]

jobs:
  deploy-to-cluster:
    # üëâ si tu actives workflow_run ci-dessus, d√©commente la ligne suivante :
    # if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: self-hosted

    env:
      REGISTRY: ghcr.io
      IMAGE_NAME: walid-isga/timi-devops-poc     # ‚Üê m√™me nom que CI, en minuscules
      K8S_NAMESPACE: timi
      K8S_DEPLOYMENT: timi-api
      KCTX: kind-timi

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Sanity check cluster (uses local kubectl)
        shell: cmd
        run: |
          kubectl config use-context %KCTX%
          kubectl get nodes

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pick image tag (prefer SHA, fallback to latest)
        id: picktag
        shell: pwsh
        run: |
          $imgSha = "${env:REGISTRY}/${env:IMAGE_NAME}:${env:GITHUB_SHA}"
          $imgLatest = "${env:REGISTRY}/${env:IMAGE_NAME}:latest"

          function Test-Tag($ref) {
            docker manifest inspect $ref *>$null
            return ($LASTEXITCODE -eq 0)
          }

          if (Test-Tag $imgSha) {
            "use_tag=${env:GITHUB_SHA}" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          }
          elseif (Test-Tag $imgLatest) {
            "use_tag=latest" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          }
          else {
            Write-Error "Neither $imgSha nor $imgLatest exists in GHCR."
            exit 1
          }

      - name: Apply manifests
        shell: cmd
        run: |
          kubectl apply -f k8s/namespace.yaml
          kubectl apply -f k8s/deployment.yaml
          kubectl apply -f k8s/service.yaml

      - name: Set deployment image to chosen tag
        shell: pwsh
        run: |
          if (-not "${{ steps.picktag.outputs.use_tag }}") {
            Write-Error "No image tag resolved (use_tag is empty)"; exit 1
          }
          $tag = "${{ steps.picktag.outputs.use_tag }}"
          kubectl -n $env:K8S_NAMESPACE set image deployment/$env:K8S_DEPLOYMENT `
            $env:K8S_DEPLOYMENT="$($env:REGISTRY)/$($env:IMAGE_NAME):$tag"

      - name: Wait for rollout
        shell: pwsh
        run: |
          kubectl -n $env:K8S_NAMESPACE rollout status deploy/$env:K8S_DEPLOYMENT --timeout=240s
          kubectl -n $env:K8S_NAMESPACE get pods -o wide


      - name: Rollback on failure
        if: failure()
        shell: cmd
        run: |
          kubectl -n %K8S_NAMESPACE% rollout undo deploy/%K8S_DEPLOYMENT%

      - name: Annotate deployment with commit metadata
        if: success()
        shell: pwsh
        run: |
          kubectl -n $env:K8S_NAMESPACE annotate deploy/$env:K8S_DEPLOYMENT `
            "app.commit-sha=$env:GITHUB_SHA" "app.run-id=$env:GITHUB_RUN_ID" --overwrite


      - name: Sanity check /health from inside cluster (ephemeral curl pod)
        shell: pwsh
        run: |
          $ns  = "${env:K8S_NAMESPACE}"
          $svc = "timi-api-svc.$ns.svc.cluster.local:5000"
          # Nettoyage si un pod pr√©c√©dent existe encore (idempotent)
          kubectl -n $ns delete pod curlcheck --ignore-not-found
          # Lancer un pod curl non interactif, sortir non-0 si /health √©choue
          kubectl -n $ns run curlcheck --restart=Never --image=curlimages/curl:8.10.1 `
            -- curl -fsS http://$svc/health
          # Attendre que le pod finisse (Succeeded) puis le supprimer
          kubectl -n $ns wait --for=condition=Ready pod/curlcheck --timeout=30s || $true
          kubectl -n $ns delete pod curlcheck --ignore-not-found
