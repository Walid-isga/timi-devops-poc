name: CD

on:
  push:
    branches: [ "main" ]
  # ðŸ‘‰ Option (recommandÃ©e) pour nâ€™exÃ©cuter CD **aprÃ¨s CI rÃ©ussi** :
  # workflow_run:
  #   workflows: ["CI"]
  #   types: [ "completed" ]

jobs:
  deploy-to-cluster:
    # ðŸ‘‰ si tu actives workflow_run ci-dessus, dÃ©commente la ligne suivante :
    # if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: self-hosted

    env:
      REGISTRY: ghcr.io
      IMAGE_NAME: walid-isga/timi-devops-poc     # â† mÃªme nom que CI, en minuscules
      K8S_NAMESPACE: timi
      K8S_DEPLOYMENT: timi-api
      KCTX: kind-timi

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Sanity check cluster (uses local kubectl)
        shell: cmd
        run: |
          kubectl config use-context %KCTX%
          kubectl get nodes

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pick image tag (prefer SHA, fallback to latest)
        id: picktag
        shell: cmd
        run: |
          setlocal enabledelayedexpansion
          set IMG_SHA=%REGISTRY%/%IMAGE_NAME%:%GITHUB_SHA%
          set IMG_LATEST=%REGISTRY%/%IMAGE_NAME%:latest
          echo Checking %IMG_SHA%
          docker manifest inspect %IMG_SHA% >NUL 2>&1
          if %errorlevel%==0 (
            echo use_tag=%GITHUB_SHA%>> %GITHUB_OUTPUT%
            exit /b 0
          )
          echo SHA not found; using latest
          docker manifest inspect %IMG_LATEST% >NUL 2>&1
          if %errorlevel% neq 0 ( echo Neither SHA nor latest exists & exit /b 1 )
          echo use_tag=latest>> %GITHUB_OUTPUT%

      - name: Apply manifests
        shell: cmd
        run: |
          kubectl apply -f k8s/namespace.yaml
          kubectl apply -f k8s/deployment.yaml
          kubectl apply -f k8s/service.yaml

      - name: Set deployment image to chosen tag
        shell: cmd
        run: |
          set TAG=${{ steps.picktag.outputs.use_tag }}
          kubectl -n %K8S_NAMESPACE% set image deployment/%K8S_DEPLOYMENT% %K8S_DEPLOYMENT%=%REGISTRY%/%IMAGE_NAME%:%TAG%

      - name: Wait for rollout
        shell: cmd
        run: |
          kubectl -n %K8S_NAMESPACE% rollout status deploy/%K8S_DEPLOYMENT% --timeout=240s
          kubectl -n %K8S_NAMESPACE% get pods -o wide

      - name: Rollback on failure
        if: failure()
        shell: cmd
        run: |
          kubectl -n %K8S_NAMESPACE% rollout undo deploy/%K8S_DEPLOYMENT%

      - name: Annotate deployment with commit metadata
        if: success()
        shell: cmd
        run: |
          kubectl -n %K8S_NAMESPACE% annotate deploy/%K8S_DEPLOYMENT% ^
            app.commit-sha=%GITHUB_SHA% app.run-id=%GITHUB_RUN_ID% --overwrite

      - name: Sanity check /health (inside cluster)
        shell: powershell
        run: |
          $ErrorActionPreference = "Stop"
          $ns  = "${env:K8S_NAMESPACE}"
          $app = "${env:K8S_DEPLOYMENT}"
          kubectl -n $ns get pods -l app=$app -o wide
          $pod = kubectl -n $ns get pod -l app=$app -o jsonpath="{.items[0].metadata.name}"
          if ([string]::IsNullOrWhiteSpace($pod)) { throw "No pod found for app=$app" }
          kubectl -n $ns exec $pod -- sh -c "wget -qO- http://localhost:5000/health || true"
