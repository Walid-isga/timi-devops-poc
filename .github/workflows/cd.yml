name: CD

on:
  push:
    branches: [ "main" ]
  # workflow_run:
  #   workflows: ["CI"]
  #   types: ["completed"]

jobs:
  deploy-to-cluster:
    runs-on: self-hosted

    env:
      REGISTRY: ghcr.io
      IMAGE_NAME: walid-isga/timi-devops-poc
      K8S_NAMESPACE: timi
      K8S_DEPLOYMENT: timi-api
      KCTX: kind-timi

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Kubectl context + nodes
        shell: pwsh
        run: |
          kubectl config use-context $env:KCTX
          kubectl get nodes

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pick image tag (prefer SHA, fallback to latest)
        id: picktag
        shell: pwsh
        run: |
          $imgSha    = "${env:REGISTRY}/${env:IMAGE_NAME}:${env:GITHUB_SHA}"
          $imgLatest = "${env:REGISTRY}/${env:IMAGE_NAME}:latest"

          function Test-Tag($ref) {
            docker manifest inspect $ref *>$null
            return ($LASTEXITCODE -eq 0)
          }

          if (Test-Tag $imgSha) {
            "use_tag=${env:GITHUB_SHA}" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          }
          elseif (Test-Tag $imgLatest) {
            "use_tag=latest" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          }
          else {
            Write-Error "Neither $imgSha nor $imgLatest exists in GHCR."
            exit 1
          }

      - name: Apply manifests
        shell: pwsh
        run: |
          kubectl apply -f k8s/namespace.yaml
          kubectl apply -f k8s/deployment.yaml
          kubectl apply -f k8s/service.yaml

      - name: Set deployment image to chosen tag
        shell: pwsh
        run: |
          $tag = "${{ steps.picktag.outputs.use_tag }}"
          kubectl -n $env:K8S_NAMESPACE set image deployment/$env:K8S_DEPLOYMENT `
            $env:K8S_DEPLOYMENT="$($env:REGISTRY)/$($env:IMAGE_NAME):$tag"

      - name: Wait for rollout
        shell: pwsh
        run: |
          kubectl -n $env:K8S_NAMESPACE rollout status deploy/$env:K8S_DEPLOYMENT --timeout=240s
          kubectl -n $env:K8S_NAMESPACE get pods -o wide

      - name: Annotate deployment with commit metadata
        if: success()
        shell: pwsh
        run: |
          kubectl -n $env:K8S_NAMESPACE annotate deploy/$env:K8S_DEPLOYMENT `
            "app.commit-sha=$env:GITHUB_SHA" "app.run-id=$env:GITHUB_RUN_ID" --overwrite

      - name: Sanity check /health from inside cluster (ephemeral curl pod)
        shell: pwsh
        run: |
          $ns  = "${env:K8S_NAMESPACE}"
          $svc = "timi-api-svc.$ns.svc.cluster.local:5000"
          kubectl -n $ns delete pod curlcheck --ignore-not-found
          kubectl -n $ns run curlcheck --restart=Never --image=curlimages/curl:8.10.1 `
            -- curl -fsS http://$svc/health
          kubectl -n $ns delete pod curlcheck --ignore-not-found

      - name: Rollback on failure
        if: failure()
        shell: pwsh
        run: |
          kubectl -n $env:K8S_NAMESPACE rollout undo deploy/$env:K8S_DEPLOYMENT
